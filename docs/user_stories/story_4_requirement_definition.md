# ストーリー4：要件定義からコーディング仕様への落とし込み（対話型開発支援）

## 概要

このストーリーでは、ユーザーが抽象的なアプリケーション要件を、エージェントとの対話を通じて具体的でテスト可能なコーディング仕様まで詳細化する過程を描いています。技術的知識が限られたユーザーでも、開発チームに連携可能な成果物を作成できます。

---

## ユーザーストーリー

**目的:** ユーザーは、アプリケーションや機能の漠然とした要件を、エージェントとの対話を通じて具体的なコーディング仕様まで落とし込み、開発チームへ連携可能な状態にしたい。

**アクター:** システム開発責任者、プロダクトオーナー、非技術系ビジネスサイド担当者

**シナリオ:**

1.  **初期要件の提示:** ユーザーは「エージェント管理システム」にアクセスし、「要件定義アシスタント」エージェントを起動する。ユーザーは、「顧客からの問い合わせを効率化するチャットボットが欲しい」といった抽象的な要件をエージェントに伝える。

2.  **対話による要件の深掘り:**
    * エージェントは、ユーザーに対して、チャットボットの目的、ターゲットユーザー、主要な機能（例: FAQ応答、予約受付、トラブルシューティング）、既存システムとの連携要件、使用する技術スタック（もしあれば）などについて、具体的な質問を投げかける。
    * ユーザーは質問に回答し、エージェントはそれらの情報を基に要件を段階的に詳細化していく。例えば、「FAQ応答では、どの程度の粒度で回答を生成しますか？」「予約受付は既存の予約システムとどのように連携しますか？」など。
    * この対話の過程で、エージェントはユーザーの意図を汲み取り、曖昧な表現を明確化したり、潜在的なニーズや考慮すべき点（例: セキュリティ、スケーラビリティ）を指摘したりする。

3.  **機能要件の整理と詳細化:** 対話が進むにつれて、エージェントはユーザーとの合意形成に基づき、以下のような項目を構造化された形式で提示する（テスト可能な範囲で簡単な例）：

    **機能要件例:**
    * **問い合わせ受付機能:**
        * ユーザーからのテキスト入力（自由記述）を受け付ける。
        * 入力された問い合わせ内容からキーワードを抽出し、既存のFAQデータベースを検索する。
        * `テストケース1`: 「営業時間」と入力された場合、「弊社の営業時間は平日9時～17時です。」という回答を返す。
        * `テストケース2`: 「パスワード忘れ」と入力された場合、パスワードリセット手順に関するFAQへのリンクを提示する。    * **予約受付連携機能:**
        * ユーザーが「予約したい」と入力した場合、予約の目的（例: 製品デモ、サポート相談）を尋ねる。
        * 目的が特定された場合、既存の予約システム（例: Calendly API）に連携し、空き時間を提示する。
        * `テストケース3`: 「製品デモの予約」と入力された場合、Calendlyのデモ予約ページURLを提示する。
        * `テストケース4`: 予約システムが応答しない場合、「現在予約システムに接続できません。後ほどお試しください。」というエラーメッセージを返す。

    **非機能要件例:**
    * 応答速度: ユーザー入力から回答提示まで3秒以内。
    * 可用性: 24時間365日稼働（定期メンテナンス時間を除く）。

4.  **コーディング仕様の提案（簡易版）:** エージェントは、整理された要件に基づき、開発者がすぐに取り掛かれるような、シンプルでテスト可能なコーディング仕様の骨子を提案する。

    **APIエンドポイント例:**
    * `POST /api/chatbot/message`: ユーザーメッセージを受け取り、チャットボットの応答を返す。
    * リクエストボディ: `{ "userId": "string", "message": "string" }`
    * レスポンスボディ: `{ "response": "string", "actionType": "string" (e.g., "text", "link", "api_call"), "payload": {} (optional) }`

    **ロジックフロー例:**
    1.  ユーザーメッセージを受信する。
    2.  自然言語処理モジュールでインテント（意図）とエンティティ（実体）を抽出する。
    3.  抽出されたインテントに基づき、対応するハンドラー関数を呼び出す。
    4.  ハンドラー関数は、FAQデータベース検索、外部API呼び出し（例: 予約システム連携）などを行う。
    5.  結果をチャットボット応答フォーマットに整形して返す。

5.  **開発チームへの連携:** ユーザーは、エージェントが生成した詳細な要件定義書とコーディング仕様の骨子をレビューし、必要に応じて修正を加えた後、開発チームにエージェントの出力結果をそのまま、または一部加工して引き渡す。これにより、要件の認識齟齬が減り、開発の効率化が期待できる。

6.  **エージェントのステータス更新:** タスクが完了し、出力が生成されるとエージェントのステータスは「完了」となる。---

## 成功判定基準

### 要件の明確性と網羅性
**基準:** 対話終了後、生成された要件定義書が、実装に必要な全ての機能的・非機能的要求を明確に記述しているか。曖昧な表現や前提が排除されているか。

**レビューポイント:**
- 各機能が「誰が、何を、どのように」できるかが具体的に記述されているか？
- 非機能要件（性能、セキュリティ、可用性など）が考慮され、測定可能な形で記述されているか？
- 要件に不足や矛盾がないか（レビュアーが開発者になったつもりで読み、疑問点が出ないか）？
- ユーザーが当初意識していなかったが、エージェントによって引き出された重要な要件（例: エラーハンドリング、国際化対応など）があるか？

### テストケースの具体性と妥当性
**基準:** 各機能要件に対して、具体的で、かつその機能が正しく動作するかを検証できるテストケースが提示されているか。

**レビューポイント:**
- 提示されたテストケースが、機能の期待される動作を網羅しているか（例: 正常系、異常系、境界値など）？
- テストケースが「入力」「期待される出力」といった形式で明確に記述され、再現性があるか？
- 開発者がこのテストケースを見れば、実装が正しいかを確認できるレベルになっているか？

### コーディング仕様の実現可能性と整合性
**基準:** 提案されたコーディング仕様の骨子（APIエンドポイント、ロジックフローなど）が、要件定義と整合しており、一般的な開発プラクティスに基づいているか。

**レビューポイント:**
- 提案されたAPIやデータ構造が、記述された要件をサポートするために十分かつ適切か？
- ロジックフローが、要件の動作を正しく表現しており、論理的な飛躍がないか？
- 提示された仕様が、実際に開発者が実装可能なレベルの粒度になっているか？（例: 使用する技術スタックとの親和性）
- セキュリティやパフォーマンスなどの非機能要件が、提示された仕様で考慮されているか？

### 開発チームへの連携準備状況
**基準:** 生成された出力が、開発チームがすぐに開発に着手できる形式で提供されているか。

**レビューポイント:**
- 生成されたドキュメントやコードの骨子が、開発ツールやバージョン管理システムにインポートしやすい形式か？
- 開発チームがレビューや質問を行う際の共通言語として機能するか？
- この出力だけで開発チームが「次に何をするべきか」を明確に理解できるか？
- ユーザーが、この成果物を自信を持って開発チームに引き渡せるレベルにあるか？